<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robust AMC Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .chart-container {
            flex: 1;
            min-width: 300px;
            min-height: 300px;
            max-height: 400px;
            position: relative;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 10px;
            box-sizing: border-box;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            width: auto !important;
            height: auto !important;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 5px;
            background-color: #e8f4f8;
            display: none;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #45a049;
        }
        select, input {
            padding: 8px;
            margin: 5px 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>Robust AMC Demo</h1>
    
    <div class="container">
        <div class="chart-container">
            <h2>Signal Visualization</h2>
            <canvas id="signalChart"></canvas>
        </div>
        
        <div class="panel">
            <h2>Generate Signal</h2>
            <div>
                <label for="modulation">Modulation Type:</label>
                <select id="modulation">
                    {% for mod in modulations %}
                    <option value="{{ mod }}">{{ mod }}</option>
                    {% endfor %}
                </select>
            </div>
            <div>
                <label for="snr">SNR (dB):</label>
                <input type="number" id="snr" value="10" step="0.1">
            </div>
            <button onclick="generateSignal()">Generate Signal</button>
            
            <div>
                <button onclick="classifySignal()" id="classifyBtn" disabled>Classify Signal</button>
            </div>
        </div>
        
        <div class="chart-container">
            <h2>Signal Constellation</h2>
            <canvas id="constellationChart"></canvas>
        </div>
        
        <div class="panel">
            <h2>Classification Result</h2>
            <div id="result" class="result">
                <p><strong>Prediction:</strong> <span id="prediction">-</span></p>
                <p><strong>Confidence:</strong> <span id="confidence">-</span></p>
                <p><strong>Expert Used:</strong> <span id="expert">-</span></p>
                <p><strong>Estimated SNR:</strong> <span id="snrEstimate">-</span> dB</p>
            </div>
        </div>
    </div>

    <script>
        let currentSignal = null;
        let signalChart = null;
        let constellationChart = null;
        
        // Initialize charts with proper dimensions
        function initCharts() {
            // Get container dimensions
            const container = document.querySelector('.chart-container');
            const containerWidth = container.offsetWidth - 40; // Account for padding
            const containerHeight = 300; // Fixed height for consistency
            
            // Signal plot
            const signalCtx = document.getElementById('signalChart').getContext('2d');
            signalChart = new Chart(signalCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        { 
                            label: 'I', 
                            data: [], 
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1,
                            pointRadius: 0,  // No points for better performance
                            borderJoinStyle: 'round'
                        },
                        { 
                            label: 'Q', 
                            data: [], 
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            pointRadius: 0,  // No points for better performance
                            borderJoinStyle: 'round'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    animation: {
                        duration: 0  // Disable animations for better performance
                    },
                    responsiveAnimationDuration: 0,
                    elements: {
                        line: {
                            tension: 0.1  // Smoother lines
                        }
                    },
                    scales: { 
                        y: { 
                            beginAtZero: true,
                            suggestedMin: -1.5,
                            suggestedMax: 1.5,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            display: true,
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxTicksLimit: 10
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true
                            }
                        }
                    }
                }
            });
            
            // Constellation plot
            const constCtx = document.getElementById('constellationChart').getContext('2d');
            constellationChart = new Chart(constCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Constellation',
                        data: [],
                        pointBackgroundColor: 'rgba(75, 192, 192, 0.6)',
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: 'rgba(75, 192, 192, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    animation: {
                        duration: 0
                    },
                    responsiveAnimationDuration: 0,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'center',
                            min: -1.5,
                            max: 1.5,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'center',
                            min: -1.5,
                            max: 1.5,
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    layout: {
                        padding: 10
                    }
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                if (signalChart) signalChart.resize();
                if (constellationChart) constellationChart.resize();
            });
        }
        
        // Generate a test signal
        async function generateSignal() {
            const modulation = document.getElementById('modulation').value;
            const snr = parseFloat(document.getElementById('snr').value);
            
            try {
                console.log('Generating signal with:', { modulation, snr });
                
                const response = await axios.post('/generate', 
                    `modulation=${encodeURIComponent(modulation)}&snr=${encodeURIComponent(snr)}`,
                    {
                        headers: { 
                            'Content-Type': 'application/x-www-form-urlencoded'
                        }
                    }
                );
                
                console.log('Signal generated successfully');
                currentSignal = response.data.iq_data;
                
                // Limit the number of points to prevent canvas overflow
                const maxPoints = 1000;
                if (currentSignal.length > maxPoints) {
                    const step = Math.ceil(currentSignal.length / maxPoints);
                    currentSignal = currentSignal.filter((_, i) => i % step === 0);
                }
                
                updateSignalPlot(currentSignal);
                document.getElementById('classifyBtn').disabled = false;
                document.getElementById('result').style.display = 'none';
                
            } catch (error) {
                console.error('Error generating signal:', error);
                if (error.response) {
                    console.error('Response data:', error.response.data);
                    console.error('Response status:', error.response.status);
                }
                alert(`Error generating signal: ${error.message}. See console for details.`);
            }
        }
        
        // Classify the current signal
        async function classifySignal() {
            if (!currentSignal) return;
            
            try {
                const response = await axios.post('/predict', {
                    iq_data: currentSignal
                });
                
                const result = response.data;
                displayResult(result);
                
            } catch (error) {
                console.error('Error classifying signal:', error);
                alert('Error classifying signal. See console for details.');
            }
        }
        
        // Update the signal plot with optimized rendering
        function updateSignalPlot(iqData) {
            try {
                if (!iqData || !Array.isArray(iqData) || iqData.length === 0) {
                    console.error('Invalid or empty IQ data received');
                    return;
                }
                
                console.log('Updating plots with data length:', iqData.length);
                
                // Function to safely extract and process I/Q data
                const processIQData = (data) => {
                    const maxPoints = 2000; // Maximum points to display
                    const i = [];
                    const q = [];
                    
                    // Calculate step size to limit number of points
                    const step = Math.max(1, Math.ceil(data.length / maxPoints));
                    
                    // Process data in chunks to avoid blocking the UI
                    for (let idx = 0; idx < data.length; idx += step) {
                        const point = data[idx];
                        if (Array.isArray(point) && point.length >= 2) {
                            i.push({x: idx, y: point[0]});
                            q.push({x: idx, y: point[1]});
                        }
                    }
                    
                    return { i, q };
                };
                
                // Process I/Q data
                const { i, q } = processIQData(iqData);
                
                // Update signal plot with new data
                signalChart.data.datasets[0].data = i;
                signalChart.data.datasets[1].data = q;
                
                // Update constellation plot (sample points for better visualization)
                const constData = [];
                const constStep = Math.max(1, Math.floor(iqData.length / 1000));
                for (let idx = 0; idx < iqData.length; idx += constStep) {
                    const point = iqData[idx];
                    if (Array.isArray(point) && point.length >= 2) {
                        constData.push({x: point[0], y: point[1]});
                    }
                }
                constellationChart.data.datasets[0].data = constData;
                
                // Update charts with minimal redraw
                signalChart.update('none');
                constellationChart.update('none');
                
            } catch (error) {
                console.error('Error in updateSignalPlot:', error);
                // Don't throw, just log the error to prevent breaking the UI
            }
        }
        
        // Display classification result
        function displayResult(result) {
            document.getElementById('prediction').textContent = result.prediction;
            document.getElementById('confidence').textContent = (result.confidence * 100).toFixed(2) + '%';
            document.getElementById('expert').textContent = result.expert_used;
            document.getElementById('snrEstimate').textContent = result.snr_estimate ? result.snr_estimate.toFixed(2) : 'N/A';
            
            // Show the result panel
            document.getElementById('result').style.display = 'block';
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
        });
    </script>
</body>
</html>
